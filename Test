/* configure uart */
 tcgetattr(fd, &options);
 options.c_cflag &= ~PARENB;
 options.c_cflag &= ~CSTOPB;
 options.c_cflag &= ~CSIZE;
 options.c_cflag |= CS8;
 options.c_cc[VTIME] = 10; // read timeout 10*100ms
 options.c_cc[VMIN] = 0;
 options.c_lflag &= ~(ICANON | ECHO | ECHOE | ISIG);
 options.c_oflag &= ~OPOST;
 options.c_iflag &= ~(ICRNL | IXON);
 cfsetispeed(&options, B115200);
 cfsetospeed(&options, B115200);
 options.c_cflag |= (CLOCAL | CREAD);
 tcflush(fd, TCIFLUSH);
 tcsetattr(fd, TCSANOW, &options);





 /* Build new RAW termios from old as baseline */
                        newt = oldt;
                        newt.c_iflag = 0;
                        newt.c_oflag = 0;
                        newt.c_lflag = 0;


                        newt.c_cflag |= (CLOCAL | CREAD);
                        newt.c_iflag &= ~(IXON | IXOFF | IXANY);

                        newt.c_cflag &= ~(CSIZE | PARENB | CSTOPB | CRTSCTS);
                        newt.c_cflag |= (CS8 | CREAD | CLOCAL);

                        /* 115200 baud (use tty helper to encode) */
                        tty_termios_encode_baud_rate(&newt, 115200, 115200);

                        /* Immediate reads */
                        newt.c_cc[VMIN]  = 1;
                        newt.c_cc[VTIME] = 0;



static DECLARE_WAIT_QUEUE_HEAD(timer_wq);
static int timer_done = 0;
static struct hrtimer kep_timer;
static ktime_t kt;


static enum hrtimer_restart kep_timer_callback(struct hrtimer *timer)
{
    timer_done = 1;
    wake_up_interruptible(&timer_wq);  // Notify user space
    return HRTIMER_NORESTART;
}

static void start_hrtimer(unsigned int timeout_ms)
{
    timer_done = 0;
    kt = ktime_set(0, timeout_ms * 1000000); // ms to ns
    hrtimer_init(&kep_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
    kep_timer.function = kep_timer_callback;
    hrtimer_start(&kep_timer, kt, HRTIMER_MODE_REL);
}



